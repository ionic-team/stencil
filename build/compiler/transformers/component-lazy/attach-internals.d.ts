import type * as d from '@stencil/core/declarations';
import ts from 'typescript';
/**
 * Create a binding for an `ElementInternals` object compatible with a
 * lazy-load ready Stencil component.
 *
 * In order to create a lazy-loaded form-associated component we need to access
 * the underlying host element (via the "$hostElement$" prop on {@link d.HostRef})
 * to make the `attachInternals` call on the right element. This means that the
 * code generated by this function depends on there being a variable in scope
 * called {@link HOST_REF_ARG} with type {@link HTMLElement}.
 *
 * If an `@AttachInternals` decorator is present on a component like this:
 *
 * ```ts
 * @AttachInternals()
 * internals: ElementInternals;
 * ```
 *
 * then this transformer will create syntax nodes which represent the
 * following TypeScript source:
 *
 * ```ts
 * if (hostRef.$hostElement$["s-ei"]) {
 *   this.internals = hostRef.$hostElement$["s-ei"];
 * } else {
 *   this.internals = hostRef.$hostElement$.attachInternals();
 *   hostRef.$hostElement$["s-ei"] = this.internals;
 * }
 * ```
 *
 * The `"s-ei"` prop on a {@link d.HostElement} may hold a reference to the
 * `ElementInternals` instance for that host. We store a reference to it
 * there in order to support HMR because `.attachInternals` may only be
 * called on an `HTMLElement` one time, so we need to store a reference to
 * the returned value across HMR updates.
 *
 * @param cmp metadata about the component of interest, gathered during compilation
 * @returns a list of expression statements
 */
export declare function createLazyAttachInternalsBinding(cmp: d.ComponentCompilerMeta): ts.Statement[];
