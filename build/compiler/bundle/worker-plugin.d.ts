import type { Plugin } from 'rollup';
import type * as d from '../../declarations';
export declare const workerPlugin: (config: d.ValidatedConfig, compilerCtx: d.CompilerCtx, buildCtx: d.BuildCtx, platform: string, inlineWorkers: boolean) => Plugin;
export declare const WORKER_HELPERS = "\nimport { consoleError } from '@stencil/core/internal';\n\n\nconst isInstanceOf = (value, className) => {\n  const C = globalThis[className];\n  return C != null && value instanceof C;\n}\nconst getTransferables = (value) => {\n  if (value != null) {\n    if (\n      isInstanceOf(value, \"ArrayBuffer\") ||\n      isInstanceOf(value, \"MessagePort\") ||\n      isInstanceOf(value, \"ImageBitmap\") ||\n      isInstanceOf(value, \"OffscreenCanvas\")\n    ) {\n      return [value];\n    }\n    if (typeof value === \"object\") {\n      if (value.constructor === Object) {\n        value = Object.values(value);\n      }\n      if (Array.isArray(value)) {\n        return value.flatMap(getTransferables);\n      }\n      return getTransferables(value.buffer);\n    }\n  }\n  return [];\n};\n\nlet pendingIds = 0;\nlet callbackIds = 0;\nconst pending = new Map();\nconst callbacks = new Map();\n\nexport const createWorker = (workerPath, workerName, workerMsgId) => {\n  const worker = new Worker(workerPath, {name:workerName});\n\n  worker.addEventListener('message', ({data}) => {\n    if (data) {\n      const workerMsg = data[0];\n      const id = data[1];\n      const value = data[2];\n\n      if (workerMsg === workerMsgId) {\n        const err = data[3];\n        const [resolve, reject, callbackIds] = pending.get(id);\n        pending.delete(id);\n\n        if (err) {\n          const errObj = (err.isError)\n            ? Object.assign(new Error(err.value.message), err.value)\n            : err.value;\n\n          consoleError(errObj);\n          reject(errObj);\n        } else {\n          if (callbackIds) {\n            callbackIds.forEach(id => callbacks.delete(id));\n          }\n          resolve(value);\n        }\n      } else if (workerMsg === workerMsgId + '.cb') {\n        try {\n          callbacks.get(id)(...value);\n        } catch (e) {\n          consoleError(e);\n        }\n      }\n    }\n  });\n\n  return worker;\n};\n\nexport const createWorkerProxy = (worker, workerMsgId, exportedMethod) => (\n  (...args) => new Promise((resolve, reject) => {\n    let pendingId = pendingIds++;\n    let i = 0;\n    let argLen = args.length;\n    let mainData = [resolve, reject];\n    pending.set(pendingId, mainData);\n\n    for (; i < argLen; i++) {\n      if (typeof args[i] === 'function') {\n        const callbackId = callbackIds++;\n        callbacks.set(callbackId, args[i]);\n        args[i] = [workerMsgId + '.cb', callbackId];\n        (mainData[2] = mainData[2] || []).push(callbackId);\n      }\n    }\n    const postMessage = (w) => (\n      w.postMessage(\n        [workerMsgId, pendingId, exportedMethod, args],\n        getTransferables(args)\n      )\n    );\n    if (worker.then) {\n      worker.then(postMessage);\n    } else {\n      postMessage(worker);\n    }\n  })\n);\n";
